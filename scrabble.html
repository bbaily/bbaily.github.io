<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Scrabble Board</title>
    <style>
      *, *::before, *::after { box-sizing: border-box; }
      :root {
        --cell: 44px;
        --gap: 2px;
        --grid-color: #ddd;
        --bg: #fafafa;
        --cell-border: #ccc;
        --focus: #4a90e2;
        --text: #111;
        --ok: #2ecc71;
        --bad: #e74c3c;
        --tw: #b00020;
        --dw: #f7b7c2;
        --tl: #004a99;
        --dl: #b9dbff;
        --locked: #f5f5dc;
      }

      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
        display: grid;
        place-content: center;
        min-height: 100vh;
      }

      .wrap { padding: 16px; display: grid; grid-template-columns: 340px auto 260px; gap: 16px; align-items: start; }

      h1 { font-size: 16px; font-weight: 600; margin: 0 0 12px; color: #333; }

      .controls, .toggles button {
        appearance: none; border: 1px solid #bbb; background: #fff; color: #222; padding: 6px 10px; border-radius: 6px; font-size: 13px; cursor: pointer;
      }
      .toggles { display: flex; gap: 8px; margin: 0 0 10px; flex-wrap: wrap; }
      .controls button:focus, .toggles button:focus { outline: none; border-color: var(--focus); box-shadow: 0 0 0 2px rgba(74,144,226,0.2); }

      /* Rack */
      .rack { border: 1px solid #ddd; border-radius: 8px; padding: 10px 12px; background: #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.06); }
      .rack .label { font-size: 12px; color: #555; margin-bottom: 6px; text-transform: uppercase; letter-spacing: .03em; }
      .rackRow { display: flex; align-items: center; gap: 8px; }
      #rackInput { width: 130px; padding: 6px 8px; border: 1px solid #bbb; border-radius: 6px; font-weight: 600; text-transform: uppercase; }
      #rackInput[readonly] { background: #f7f7f7; }
      .rack.locked #rackInput { background: #efefef; color: #777; border-color: #ddd; }
      .rack.locked .rtile { opacity: 0.55; }
      .rackBtns { display: flex; gap: 6px; }
      .rackBtns button { appearance: none; border: 1px solid #bbb; background: #fff; padding: 6px 8px; border-radius: 6px; cursor: pointer; }
      .rackTiles { display: grid; grid-template-columns: repeat(7, 28px); gap: 6px; margin-top: 8px; }
      .rtile { width: 28px; height: 28px; border: 1px solid #ccc; border-radius: 4px; display: grid; place-items: center; font-weight: 700; background: #fff; }

      #board {
        display: grid; grid-template-columns: repeat(15, var(--cell)); grid-auto-rows: var(--cell); gap: var(--gap);
        background: var(--grid-color); padding: var(--gap); border: 8px solid var(--ok); border-radius: 6px; box-shadow: 0 1px 2px rgba(0,0,0,0.06);
        grid-column: 2; grid-row: 1;
      }
      #board.is-invalid { border-color: var(--bad); }

      #scorePanel, #bagPanel { min-width: 140px; border: 1px solid #ddd; border-radius: 8px; padding: 10px 12px; background: #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.06); align-self: start; }
      #scorePanel .label, #bagPanel .label { font-size: 12px; color: #555; margin-bottom: 6px; text-transform: uppercase; letter-spacing: .03em; }
      #scoreValue { font-weight: 700; font-size: 24px; }

      #fenPanel { margin-top: 12px; border: 1px solid #ddd; border-radius: 8px; padding: 10px 12px; background: #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.06); }
      #fenPanel .label { font-size: 12px; color: #555; margin-bottom: 6px; text-transform: uppercase; letter-spacing: .03em; }
      #fenBox { width: 100%; height: 200px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px; padding: 6px; border: 1px solid #bbb; border-radius: 6px; resize: vertical; }
      #fenBtns { display:flex; gap:8px; margin-top:8px; flex-wrap: nowrap; }

      #rightRail { display: grid; gap: 12px; align-content: start; grid-column: 3; grid-row: 1; max-height: calc((var(--cell) * 15) + (var(--gap) * 16) + 16px); overflow: auto; }

      .square { width: var(--cell); height: var(--cell); border-radius: 4px; position: relative; }
      .square.tw { background: var(--tw); }
      .square.dw { background: var(--dw); }
      .square.tl { background: var(--tl); }
      .square.dl { background: var(--dl); }
      .square.locked { background: var(--locked) !important; }
      .square.blank .cell { text-transform: lowercase; }

      .cell { width: 100%; height: 100%; border: 1px solid var(--cell-border); background: transparent; text-align: center; font-weight: 600; font-size: 18px; text-transform: uppercase; outline: none; border-radius: 4px; caret-color: transparent; margin: 0; padding: 0; box-sizing: border-box; }
      .cell:focus { border-color: var(--focus); box-shadow: 0 0 0 2px rgba(74,144,226,0.2); }

      footer { margin-top: 10px; font-size: 12px; color: #666; text-align: left; }

      .panel { display: grid; gap: 10px; align-content: start; }
      #wordsPanel { border: 1px solid #ddd; border-radius: 8px; padding: 10px 12px; background: #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.06); }
      #wordsPanel .label { font-size: 12px; color: #555; margin-bottom: 6px; text-transform: uppercase; letter-spacing: .03em; }
      #wordsList { max-height: 300px; overflow: auto; font-size: 13px; line-height: 1.4; }
      .wordItem { display: flex; justify-content: space-between; gap: 8px; padding: 2px 0; border-bottom: 1px dashed #eee; }
      .wordItem:last-child { border-bottom: 0; }
      .ok { color: #1a7f37; font-weight: 600; }
      .bad { color: #b00020; font-weight: 600; }

      /* Tile bag */
      #tileBag { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; font-size: 12px; }
      .tbItem { display: flex; justify-content: flex-start; align-items: center; gap: 4px; padding: 4px 6px; border: 1px solid #eee; border-radius: 6px; background: #fafafa; }
      .tbItem .ltr { font-weight: 700; }
      .tbItem .cnt { font-variant-numeric: tabular-nums; }
      .tbItem.neg { color: #b00020; border-color: #f2c0c6; background: #fff5f6; }

      

      @media (max-width: 700px) { :root { --cell: 34px; } }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="panel">
        <h1>15√ó15 Editable Board</h1>
        <div class="toggles">
          <button id="boardToggleBtn" type="button">Lock Board</button>
          <button id="rackToggleBtn" type="button">Lock Rack</button>
        </div>
        <div class="rack" id="rack">
          <div class="label">Rack (max 7)</div>
          <div class="rackRow">
            <input id="rackInput" type="text" maxlength="7" placeholder="letters" autocomplete="off" spellcheck="false" />
            <div class="rackBtns">
              <button id="rackTrash" type="button" title="Return all played letters">üóëÔ∏è</button>
              <button id="rackShuffle" type="button" title="Shuffle">üîÄ</button>
              <button id="rackSort" type="button" title="Sort A‚ÜíZ">üî§</button>
            </div>
          </div>
          <div class="rackTiles" id="rackTiles"></div>
        </div>
        <div class="legend" aria-hidden="true" style="font-size:13px; color:#444; display:flex; flex-direction:column; gap:6px;">
          <div style="display:flex; align-items:center; gap:8px;"><span style="display:inline-block; width:16px; height:16px; background: var(--tw); border-radius:3px;"></span> Triple Word</div>
          <div style="display:flex; align-items:center; gap:8px;"><span style="display:inline-block; width:16px; height:16px; background: var(--dw); border-radius:3px;"></span> Double Word</div>
          <div style="display:flex; align-items:center; gap:8px;"><span style="display:inline-block; width:16px; height:16px; background: var(--tl); border-radius:3px;"></span> Triple Letter</div>
          <div style="display:flex; align-items:center; gap:8px;"><span style="display:inline-block; width:16px; height:16px; background: var(--dl); border-radius:3px;"></span> Double Letter</div>
        </div>
        <div id="wordsPanel">
          <div class="label">Words</div>
          <div id="wordsList">Lock the board to validate words.</div>
        </div>
      </div>

      <div id="board" aria-label="Scrabble-like board" role="grid"></div>

      <aside id="rightRail">
        <aside id="scorePanel" aria-live="polite">
          <div class="label">Score</div>
          <div id="scoreValue">0</div>
          <div id="bingoMsg" style="margin-top:6px; font-size:12px; color:#1a7f37; font-weight:700; display:none;">Bingo! +50</div>
        </aside>
        <aside id="fenPanel">
          <div class="label">Puzzle Notation</div>
          <textarea id="fenBox" placeholder="15 lines of 15 characters (. for empty, A-Z for letters, a-z for blanks), then a blank line, then 7-letter rack."></textarea>
          <div id="fenBtns">
            <button id="importBtn" type="button">Import Puzzle</button>
            <button id="exportBtn" type="button">Export Puzzle</button>
          </div>
        </aside>
        <aside id="bagPanel">
          <div class="label">Tile Bag</div>
          <div id="tileBag"></div>
        </aside>
      </aside>
    </div>

    <script src="./dictionary.js"></script>
    <script>
      (function () {
        const size = 15;
        const board = document.getElementById('board');
        const boardToggleBtn = document.getElementById('boardToggleBtn');
        const rackToggleBtn = document.getElementById('rackToggleBtn');
        let puzzleMode = false;
        const scoreEl = document.getElementById('scoreValue');
        const wordsListEl = document.getElementById('wordsList');
        let filterMoveWords = false;
        const rackInput = document.getElementById('rackInput');
        const rackTiles = document.getElementById('rackTiles');
        const rackTrash = document.getElementById('rackTrash');
        const rackShuffle = document.getElementById('rackShuffle');
        const rackSort = document.getElementById('rackSort');
        const bingoMsg = document.getElementById('bingoMsg');
        const rack = document.getElementById('rack');
        let rackLocked = false;
        const fenBox = document.getElementById('fenBox');
        const importBtn = document.getElementById('importBtn');
        const exportBtn = document.getElementById('exportBtn');
        

        const TW = new Set(['0,0','0,7','0,14','7,0','7,14','14,0','14,7','14,14']);
        const DW = new Set(['1,1','2,2','3,3','4,4','7,7','10,10','11,11','12,12','13,13','1,13','2,12','3,11','4,10','10,4','11,3','12,2','13,1']);
        const TL = new Set(['1,5','1,9','5,1','5,5','5,9','5,13','9,1','9,5','9,9','9,13','13,5','13,9']);
        const DL = new Set(['0,3','0,11','2,6','2,8','3,0','3,7','3,14','6,2','6,6','6,8','6,12','7,3','7,11','8,2','8,6','8,8','8,12','11,0','11,7','11,14','12,6','12,8','14,3','14,11']);

        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            const square = document.createElement('div');
            square.className = 'square';
            const key = r + ',' + c;
            if (TW.has(key)) square.classList.add('tw');
            else if (DW.has(key)) square.classList.add('dw');
            else if (TL.has(key)) square.classList.add('tl');
            else if (DL.has(key)) square.classList.add('dl');
            square.dataset.index = String(r * size + c);

            const input = document.createElement('input');
            input.className = 'cell';
            input.setAttribute('maxlength', '1');
            input.setAttribute('aria-label', 'Row ' + (r + 1) + ' Column ' + (c + 1));
            input.setAttribute('role', 'gridcell');
            input.inputMode = 'latin';
            input.autocomplete = 'off';
            input.spellcheck = false;
            input.dataset.index = String(r * size + c);

            input.addEventListener('input', (e) => {
              const v = e.target.value.toUpperCase().replace(/[^A-Z]/g, '');
              e.target.value = v.slice(0, 1);
              const prev = e.target.dataset.prev || '';
              const now = e.target.value;
              if (puzzleMode) {
                if (now && now !== prev && !canUseFromRack(now, parseInt(e.target.dataset.index, 10), prev)) {
                  e.target.value = prev;
                }
                updateRackTiles();
                validateSolution();
                validateBoardWords();
              }
              e.target.dataset.prev = e.target.value;
              updateTileBag();
            });

            input.addEventListener('keydown', (e) => {
              if (e.key === ' ' || e.key === 'Spacebar') { e.preventDefault(); return; }
              if (e.key === '?') {
                e.preventDefault();
                const idx = parseInt(e.currentTarget.dataset.index, 10);
                const sq = squareByIndex(idx);
                const inp = getInput(sq);
                if (sq.classList.contains('locked')) return;
                if ((inp.value || '').trim().length === 0) return;
                if (!puzzleMode) {
                  if (sq.classList.contains('blank')) { sq.classList.remove('blank'); delete sq.dataset.forceBlank; delete sq.dataset.blank; }
                  else { sq.classList.add('blank'); sq.dataset.forceBlank = '1'; sq.dataset.blank = '1'; }
                } else {
                  if (sq.dataset.forceBlank === '1') delete sq.dataset.forceBlank; else sq.dataset.forceBlank = '1';
                  reassignAllocations();
                  updateRackTiles();
                }
                if (puzzleMode) { validateSolution(); validateBoardWords(); }
                updateTileBag();
                return;
              }

              const idx = parseInt(e.currentTarget.dataset.index, 10);
              const row = Math.floor(idx / size);
              const col = idx % size;
              let nextIdx = null;
              if (e.key === 'ArrowLeft' && col > 0) nextIdx = idx - 1;
              else if (e.key === 'ArrowRight' && col < size - 1) nextIdx = idx + 1;
              else if (e.key === 'ArrowUp' && row > 0) nextIdx = idx - size;
              else if (e.key === 'ArrowDown' && row < size - 1) nextIdx = idx + size;
              if (nextIdx !== null) { e.preventDefault(); const next = inputByIndex(nextIdx); next?.focus(); next?.select?.(); }
            });

            square.appendChild(input);
            board.appendChild(square);
          }
        }

        function squareByIndex(i) { return board.children[i]; }
        function inputByIndex(i) { const sq = squareByIndex(i); return sq ? sq.querySelector('input.cell') : null; }
        function getInput(el) { return el && (el.matches && el.matches('.cell') ? el : el.querySelector('input.cell')); }

        function sanitizeRack(str) { return (str || '').toUpperCase().replace(/[^A-Z?]/g, '').slice(0,7); }
        function getRackArray() { return sanitizeRack(rackInput.value).split(''); }
        function countMap(arr) { const m=Object.create(null); for (const ch of arr) m[ch]=(m[ch]||0)+1; return m; }
        function getRackCounts(){ return countMap(getRackArray()); }
        function computeUsage(excludeIndex = -1) {
          const letters = Object.create(null);
          let blanks = 0;
          for (let i=0;i<board.children.length;i++){
            if (i === excludeIndex) continue;
            const sq=board.children[i];
            if (sq.classList.contains('locked')) continue;
            const inp = getInput(sq);
            const ch = (inp && inp.value || '').trim().toUpperCase();
            if (!ch) continue;
            if (sq.classList.contains('blank')) blanks++;
            else letters[ch] = (letters[ch]||0) + 1;
          }
          return {letters, blanks};
        }
        function canUseFromRack(letter, cellIndex, prevLetter) {
          const rackCounts = getRackCounts();
          const usage = computeUsage(cellIndex);
          const realAvail = (rackCounts[letter]||0) - (usage.letters[letter]||0);
          if (realAvail > 0) return true;
          const blankAvail = (rackCounts['?']||0) - usage.blanks;
          return blankAvail > 0;
        }
        function getRemainingRackArray() {
          const rack = getRackArray();
          const usage = computeUsage();
          const remain = [];
          const usedLetters = Object.create(null);
          let usedBlanks = 0;
          for (const ch of rack) {
            if (ch === '?') {
              if (usedBlanks < usage.blanks) usedBlanks++;
              else remain.push(ch);
            } else {
              const need = usage.letters[ch]||0;
              const have = usedLetters[ch]||0;
              if (have < need) usedLetters[ch] = have + 1; else remain.push(ch);
            }
          }
          return remain;
        }
        function updateRackTiles() {
          const remain = getRemainingRackArray();
          rackTiles.innerHTML = '';
          for (const ch of remain) {
            const d = document.createElement('div');
            d.className = 'rtile';
            d.textContent = ch;
            rackTiles.appendChild(d);
          }
          updateTileBag();
        }

        function setCell(r, c, ch, isBlank) {
          const sq = board.children[idx(r, c)];
          const inp = getInput(sq);
          inp.value = ch || '';
          inp.dataset.prev = inp.value;
          if (isBlank) { sq.classList.add('blank'); sq.dataset.blank='1'; }
          else { sq.classList.remove('blank'); delete sq.dataset.blank; delete sq.dataset.forceBlank; }
        }

        function clearBoardUnlocked() {
          for (let i=0;i<board.children.length;i++){
            const sq=board.children[i];
            const inp=getInput(sq);
            inp.value=''; inp.dataset.prev='';
            sq.classList.remove('blank','locked');
            delete sq.dataset.blank; delete sq.dataset.forceBlank;
            inp.readOnly=false; inp.removeAttribute('aria-readonly');
          }
          puzzleMode = false;
        }

        function exportPuzzle() {
          if (!puzzleMode || !rackLocked) { alert('Please lock board and rack before exporting.'); return; }
          let lines = [];
          for (let r=0;r<size;r++){
            let row='';
            for (let c=0;c<size;c++){
              const ch = getChar(r,c);
              if (!ch) { row+='.'; continue; }
              row += isBlank(r,c) ? ch.toLowerCase() : ch.toUpperCase();
            }
            lines.push(row);
          }
          lines.push('');
          lines.push(sanitizeRack(rackInput.value));
          fenBox.value = lines.join('\n');
        }

        function importPuzzle() {
          const raw = fenBox.value.replace(/\r/g,'');
          const lines = raw.split('\n');
          if (lines.length < 17) { alert('Invalid format: need 15 lines, blank line, then rack.'); return; }
          const grid = lines.slice(0,15);
          const rackLine = lines[16] || '';
          if (grid.some(l => l.length !== 15)) { alert('Each of the first 15 lines must have exactly 15 characters.'); return; }
          clearBoardUnlocked();
          for (let r=0;r<15;r++){
            for (let c=0;c<15;c++){
              const ch = grid[r][c];
              if (ch === '.') { setCell(r,c,'',false); continue; }
              if (/[A-Z]/.test(ch)) { setCell(r,c,ch.toUpperCase(),false); }
              else if (/[a-z]/.test(ch)) { setCell(r,c,ch.toUpperCase(),true); }
              else { alert('Invalid character in grid. Use ., A-Z, a-z.'); return; }
            }
          }
          for (let i=0;i<board.children.length;i++){
            const sq=board.children[i];
            const inp=getInput(sq);
            const has=(inp.value||'').trim().length>0;
            if (has){ inp.readOnly=true; inp.setAttribute('aria-readonly','true'); sq.classList.add('locked'); }
            else { inp.readOnly=false; inp.removeAttribute('aria-readonly'); sq.classList.remove('locked'); }
          }
          puzzleMode = true;
          rackInput.value = sanitizeRack(rackLine);
          lockRack();
          updateRackTiles();
          updateTileBag();
          validateSolution();
          validateBoardWords();
          updateToggleLabels();
        }

        rackInput.addEventListener('input', () => {
          if (rackLocked) return;
          rackInput.value = sanitizeRack(rackInput.value);
          if (puzzleMode) { reassignAllocations(); validateSolution(); validateBoardWords(); }
          updateRackTiles();
          updateTileBag();
        });
        rackShuffle.addEventListener('click', () => {
          const arr = getRackArray();
          for (let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
          rackInput.value = arr.join('');
          if (puzzleMode) { reassignAllocations(); validateSolution(); validateBoardWords(); }
          updateRackTiles();
          updateTileBag();
        });
        rackSort.addEventListener('click', () => {
          const arr = getRackArray().sort();
          rackInput.value = arr.join('');
          if (puzzleMode) { reassignAllocations(); validateSolution(); validateBoardWords(); }
          updateRackTiles();
          updateTileBag();
        });
        rackTrash.addEventListener('click', () => {
          for (let i=0;i<board.children.length;i++){
            const sq = board.children[i];
            if (sq.classList.contains('locked')) continue;
            const inp = getInput(sq);
            if (inp && inp.value) { inp.value=''; inp.dataset.prev=''; delete sq.dataset.forceBlank; sq.classList.remove('blank'); }
          }
          updateRackTiles();
          updateTileBag();
          if (puzzleMode) { validateSolution(); validateBoardWords(); }
        });

        function reassignAllocations() {
          if (!puzzleMode) return;
          const rackCounts = getRackCounts();
          const lettersAvail = Object.assign(Object.create(null), rackCounts);
          let blanksAvail = lettersAvail['?'] || 0;
          delete lettersAvail['?'];
          for (let i=0;i<board.children.length;i++){
            const sq = board.children[i];
            if (sq.classList.contains('locked')) continue;
            sq.classList.remove('blank');
            delete sq.dataset.blank;
          }
          for (let i=0;i<board.children.length;i++){
            const sq = board.children[i];
            if (sq.classList.contains('locked')) continue;
            if (sq.dataset.forceBlank === '1'){
              const inp = getInput(sq);
              const ch = (inp && inp.value || '').trim().toUpperCase();
              if (!ch) { delete sq.dataset.forceBlank; continue; }
              if (blanksAvail > 0){ blanksAvail--; sq.classList.add('blank'); sq.dataset.blank = '1'; }
              else { delete sq.dataset.forceBlank; }
            }
          }
          for (let i=0;i<board.children.length;i++){
            const sq = board.children[i];
            if (sq.classList.contains('locked')) continue;
            const inp = getInput(sq);
            const ch = (inp && inp.value || '').trim().toUpperCase();
            if (!ch) continue;
            if (sq.classList.contains('blank')) continue;
            const have = lettersAvail[ch] || 0;
            if (have > 0) { lettersAvail[ch] = have - 1; }
            else if (blanksAvail > 0) { blanksAvail--; sq.classList.add('blank'); sq.dataset.blank = '1'; }
            else { inp.value = ''; inp.dataset.prev = ''; delete sq.dataset.forceBlank; sq.classList.remove('blank'); delete sq.dataset.blank; }
          }
        }

        function lockRack() { rackLocked = true; rackInput.readOnly = true; rack.classList.add('locked'); }
        function unlockRack() { rackLocked = false; rackInput.readOnly = false; rack.classList.remove('locked'); }

        function getNewTiles() {
          const pos = [];
          for (let i = 0; i < board.children.length; i++) {
            const sq = board.children[i];
            const input = getInput(sq);
            const has = (input && input.value || '').trim().length > 0;
            if (has && !sq.classList.contains('locked')) pos.push(i);
          }
          return pos;
        }

        function lockBoard() {
          if (puzzleMode) {
            const newTiles = getNewTiles();
            if (newTiles.length === 0) { filterMoveWords = true; validateBoardWords(); return; }
          }
          for (const square of board.children) {
            const input = getInput(square);
            const hasLetter = (input.value || '').trim().length > 0;
            if (hasLetter) { input.readOnly = true; input.setAttribute('aria-readonly', 'true'); square.classList.add('locked'); }
            else { input.readOnly = false; input.removeAttribute('aria-readonly'); square.classList.remove('locked'); }
          }
          puzzleMode = true;
          updateRackTiles();
          validateSolution();
          validateBoardWords();
        }

        function unlockBoard() {
          for (const square of board.children) {
            const input = getInput(square);
            input.readOnly = false;
            input.removeAttribute('aria-readonly');
            square.classList.remove('locked');
          }
          puzzleMode = false;
          setValidity(true);
          filterMoveWords = false;
          wordsListEl.textContent = 'Lock the board to validate words.';
          updateRackTiles();
          updateTileBag();
        }

        function setValidity(isValid) { board.classList.toggle('is-invalid', !isValid); }
        function idx(r, c) { return r * size + c; }
        function rc(i) { return { r: Math.floor(i / size), c: i % size }; }
        function inBounds(r, c) { return r >= 0 && r < size && c >= 0 && c < size; }

        function isLockedCell(r, c) {
          const sq = board.children[idx(r, c)];
          const input = getInput(sq);
          return sq && sq.classList.contains('locked') && input && (input.value || '').trim().length > 0;
        }
        function hasLetter(elOrSquare) { const input = getInput(elOrSquare); return input && (input.value || '').trim().length > 0; }

        function getChar(r, c) { const sq = board.children[idx(r, c)]; if (!sq) return ''; const inp = sq.querySelector('input.cell'); return ((inp && inp.value) || '').trim().toUpperCase(); }
        function isBlank(r, c) { const sq = board.children[idx(r, c)]; return !!(sq && sq.classList.contains('blank')); }

        // Tile bag tracker
        const BASE_BAG = { 'A': 9, 'B': 2, 'C': 2, 'D': 4, 'E': 12, 'F': 2, 'G': 3, 'H': 2, 'I': 9, 'J': 1, 'K': 1, 'L': 4, 'M': 2, 'N': 6, 'O': 8, 'P': 2, 'Q': 1, 'R': 6, 'S': 4, 'T': 6, 'U': 4, 'V': 2, 'W': 2, 'X': 1, 'Y': 2, 'Z': 1, '?': 2 };
        const ORDER_BAG = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ?'.split('');
        const tileBagEl = document.getElementById('tileBag');
        function computeBagUsageAll(){
          const use = Object.create(null);
          for (let i=0;i<board.children.length;i++){
            const sq = board.children[i];
            const inp = getInput(sq);
            const ch = (inp && inp.value || '').trim().toUpperCase();
            if (!ch) continue;
            if (sq.classList.contains('blank')) use['?'] = (use['?']||0)+1; else use[ch] = (use[ch]||0)+1;
          }
          const rackRemain = getRemainingRackArray();
          for (const ch of rackRemain){ if (!ch) continue; use[ch] = (use[ch]||0)+1; }
          return use;
        }
        function updateTileBag(){
          if (!tileBagEl) return;
          const usage = computeBagUsageAll();
          const frag = document.createDocumentFragment();
          for (const ltr of ORDER_BAG){
            const rem = (BASE_BAG[ltr]||0) - (usage[ltr]||0);
            const item = document.createElement('div');
            item.className = 'tbItem' + (rem < 0 ? ' neg' : '');
            const left = document.createElement('span'); left.className = 'ltr'; left.textContent = ltr;
            const right = document.createElement('span'); right.className = 'cnt'; right.textContent = ' ' + String(rem);
            item.appendChild(left); item.appendChild(right); frag.appendChild(item);
          }
          tileBagEl.innerHTML = '';
          tileBagEl.appendChild(frag);
        }

        function toggleBoard(){ puzzleMode ? unlockBoard() : lockBoard(); updateToggleLabels(); }
        function toggleRack(){ rackLocked ? unlockRack() : lockRack(); updateToggleLabels(); }
        boardToggleBtn.addEventListener('click', toggleBoard);
        rackToggleBtn.addEventListener('click', toggleRack);
        document.getElementById('exportBtn').addEventListener('click', exportPuzzle);
        document.getElementById('importBtn').addEventListener('click', importPuzzle);
        updateToggleLabels();
        updateTileBag();

        function updateToggleLabels(){
          boardToggleBtn.textContent = puzzleMode ? 'Unlock Board' : 'Lock Board';
          rackToggleBtn.textContent = rackLocked ? 'Unlock Rack' : 'Lock Rack';
          const canExport = puzzleMode && rackLocked;
          const exportBtnEl = document.getElementById('exportBtn');
          if (exportBtnEl) exportBtnEl.disabled = !canExport;
        }

        function idx(r, c) { return r * size + c; }
        function getPremium(r, c) {
          const key = r+','+c;
          if (TW.has(key)) return 'tw';
          if (DW.has(key)) return 'dw';
          if (TL.has(key)) return 'tl';
          if (DL.has(key)) return 'dl';
          return '';
        }
        const letterScore = { A:1,B:3,C:3,D:2,E:1,F:4,G:2,H:4,I:1,J:8,K:5,L:1,M:3,N:1,O:1,P:3,Q:10,R:1,S:1,T:1,U:1,V:4,W:4,X:8,Y:4,Z:10 };

        function inWordBounds(r,c){ return r>=0 && r<size && c>=0 && c<size; }
        function computeTotalScore(mode, line, minPos, maxPos) {
          let mainWordMult = 1; let mainSum = 0;
          for (let i = minPos; i <= maxPos; i++) {
            const r = mode === 'row' ? line : i; const c = mode === 'row' ? i : line;
            const sq = board.children[idx(r, c)]; const ch = getChar(r, c); if (!ch) continue;
            const base = letterScore[ch] || 0; const isNew = !sq.classList.contains('locked'); const blankHere = isBlank(r,c);
            let letterVal = blankHere ? 0 : base;
            if (isNew) {
              const prem = getPremium(r, c);
              if (!blankHere) { if (prem === 'dl') letterVal *= 2; else if (prem === 'tl') letterVal *= 3; }
              if (prem === 'dw') mainWordMult *= 2; else if (prem === 'tw') mainWordMult *= 3;
            }
            mainSum += letterVal;
          }
          const mainLen = maxPos - minPos + 1;
          let total = (mainLen >= 2 ? (mainSum * mainWordMult) : 0);

          for (let i = minPos; i <= maxPos; i++) {
            const r = mode === 'row' ? line : i; const c = mode === 'row' ? i : line; const sq = board.children[idx(r, c)];
            if (!sq || sq.classList.contains('locked')) continue; const ch = getChar(r, c); if (!ch) continue;
            const dr = mode === 'row' ? 1 : 0; const dc = mode === 'row' ? 0 : 1;
            let r0 = r, c0 = c; while (inWordBounds(r0 - dr, c0 - dc) && hasLetter(board.children[idx(r0 - dr, c0 - dc)])) { r0 -= dr; c0 -= dc; }
            let r1 = r, c1 = c; while (inWordBounds(r1 + dr, c1 + dc) && hasLetter(board.children[idx(r1 + dr, c1 + dc)])) { r1 += dr; c1 += dc; }
            if (r0 === r1 && c0 === c1) continue; // single-letter "word" ‚Äî skip
            // Require that the perpendicular word includes at least one pre-existing locked tile
            let hasLockedNeighbor = false;
            {
              let rr = r0, cc = c0;
              while (true) {
                const sqq = board.children[idx(rr, cc)];
                if (!(rr === r && cc === c) && sqq && sqq.classList.contains('locked')) { hasLockedNeighbor = true; break; }
                if (rr === r1 && cc === c1) break;
                rr += dr; cc += dc;
              }
            }
            if (!hasLockedNeighbor) continue;
            let wordMult = 1; let sum = 0; let rr = r0, cc = c0;
            while (true) {
              const ch2 = getChar(rr, cc); const base2 = letterScore[ch2] || 0;
              if (rr === r && cc === c) {
                const newBlank = isBlank(rr, cc); let lv = newBlank ? 0 : base2; const prem = getPremium(rr, cc);
                if (!newBlank) { if (prem === 'dl') lv *= 2; else if (prem === 'tl') lv *= 3; }
                if (prem === 'dw') wordMult *= 2; else if (prem === 'tw') wordMult *= 3; sum += lv;
              } else { sum += base2; }
              if (rr === r1 && cc === c1) break; rr += dr; cc += dc;
            }
            total += sum * wordMult;
          }
          return total;
        }

        // Detailed scoring with debug lines
        function computeTotalScoreDetailed(mode, line, minPos, maxPos) {
          const dbg = [];
          dbg.push(`Mode: ${mode} line: ${line+1}, segment: [${minPos+1}, ${maxPos+1}]`);
          let mainWordMult = 1; let mainSum = 0;
          for (let i = minPos; i <= maxPos; i++) {
            const r = mode === 'row' ? line : i; const c = mode === 'row' ? i : line;
            const sq = board.children[idx(r, c)]; const ch = getChar(r, c); if (!ch) continue;
            const base = letterScore[ch] || 0; const isNew = !sq.classList.contains('locked'); const blankHere = isBlank(r,c);
            let letterVal = blankHere ? 0 : base;
            let prem = '';
            if (isNew) {
              prem = getPremium(r, c);
              if (!blankHere) { if (prem === 'dl') letterVal *= 2; else if (prem === 'tl') letterVal *= 3; }
              if (prem === 'dw') mainWordMult *= 2; else if (prem === 'tw') mainWordMult *= 3;
            }
            mainSum += letterVal;
            dbg.push(` Main ${isNew?'+':'¬∑'} (${r+1},${c+1}) ${ch}${blankHere?'(blank)':''} base=${base}${prem?` prem=${prem}`:''} -> ${letterVal}`);
          }
          const mainLen = maxPos - minPos + 1;
          let total = 0;
          if (mainLen >= 2) {
            total += mainSum * mainWordMult;
            dbg.push(` Main sum=${mainSum} √ó wordMult=${mainWordMult} = ${mainSum*mainWordMult}`);
          } else {
            dbg.push(' Main length is 1 -> skip main scoring');
          }

          for (let i = minPos; i <= maxPos; i++) {
            const r = mode === 'row' ? line : i; const c = mode === 'row' ? i : line; const sq = board.children[idx(r, c)];
            if (!sq || sq.classList.contains('locked')) continue; const ch = getChar(r, c); if (!ch) continue;
            const dr = mode === 'row' ? 1 : 0; const dc = mode === 'row' ? 0 : 1;
            let r0 = r, c0 = c; while (inWordBounds(r0 - dr, c0 - dc) && hasLetter(board.children[idx(r0 - dr, c0 - dc)])) { r0 -= dr; c0 -= dc; }
            let r1 = r, c1 = c; while (inWordBounds(r1 + dr, c1 + dc) && hasLetter(board.children[idx(r1 + dr, c1 + dc)])) { r1 += dr; c1 += dc; }
            if (r0 === r1 && c0 === c1) { dbg.push(` Cross (${r+1},${c+1}) single-letter -> skip`); continue; }
            let hasLockedNeighbor = false;
            {
              let rr = r0, cc = c0;
              while (true) {
                const sqq = board.children[idx(rr, cc)];
                if (!(rr === r && cc === c) && sqq && sqq.classList.contains('locked')) { hasLockedNeighbor = true; break; }
                if (rr === r1 && cc === c1) break;
                rr += dr; cc += dc;
              }
            }
            if (!hasLockedNeighbor) { dbg.push(` Cross (${r+1},${c+1}) no locked tile -> skip`); continue; }
            let wordMult = 1; let sum = 0; let rr = r0, cc = c0;
            while (true) {
              const ch2 = getChar(rr, cc); const base2 = letterScore[ch2] || 0;
              if (rr === r && cc === c) {
                const newBlank = isBlank(rr, cc); let lv = newBlank ? 0 : base2; const prem = getPremium(rr, cc);
                if (!newBlank) { if (prem === 'dl') lv *= 2; else if (prem === 'tl') lv *= 3; }
                if (prem === 'dw') wordMult *= 2; else if (prem === 'tw') wordMult *= 3; sum += lv;
                dbg.push(` Cross + (${rr+1},${cc+1}) ${ch2}${newBlank?'(blank)':''} base=${base2}${prem?` prem=${prem}`:''} -> ${lv}`);
              } else { sum += base2; dbg.push(` Cross   (${rr+1},${cc+1}) ${ch2} base=${base2}`); }
              if (rr === r1 && cc === c1) break; rr += dr; cc += dc;
            }
            dbg.push(` Cross sum=${sum} √ó wordMult=${wordMult} = ${sum*wordMult}`);
            total += sum * wordMult;
          }
          return { total, debug: dbg };
        }

        function validateSolution() {
          if (!puzzleMode) { setValidity(true); updateScore(0); return; }
          const newCells = []; const lockedCells = [];
          for (let i = 0; i < board.children.length; i++) {
            const sq = board.children[i]; const input = getInput(sq); const val = (input && input.value || '').trim(); if (!val) continue; const { r, c } = rc(i);
            if (sq.classList.contains('locked')) lockedCells.push({ r, c }); else newCells.push({ r, c });
          }
          if (newCells.length === 0) { setValidity(true); updateScore(0); return; }
          const rows = new Set(newCells.map(p => p.r)); const cols = new Set(newCells.map(p => p.c));
          let mode = null, line = null; if (rows.size === 1) { mode = 'row'; line = newCells[0].r; } else if (cols.size === 1) { mode = 'col'; line = newCells[0].c; } else { setValidity(false); updateScore(0); return; }
          // Occupancy for this line (locked or new letters)
          const lineHasLetter = new Array(size).fill(false);
          for (let i = 0; i < size; i++) {
            const r = mode === 'row' ? line : i;
            const c = mode === 'row' ? i : line;
            const sq = board.children[idx(r, c)];
            lineHasLetter[i] = sq && hasLetter(sq);
          }
          // Compute the contiguous segment containing the new tiles only
          const newIdxs = [];
          for (const p of newCells) {
            if ((mode === 'row' && p.r === line) || (mode === 'col' && p.c === line)) {
              newIdxs.push(mode === 'row' ? p.c : p.r);
            }
          }
          if (newIdxs.length === 0) { setValidity(false); updateScore(0); return; }
          let minPos = Math.min(...newIdxs);
          let maxPos = Math.max(...newIdxs);
          while (minPos > 0 && lineHasLetter[minPos - 1]) minPos--;
          while (maxPos < size - 1 && lineHasLetter[maxPos + 1]) maxPos++;
          // Ensure no gaps within the main segment
          for (let i = minPos; i <= maxPos; i++) {
            if (!lineHasLetter[i]) { setValidity(false); updateScore(0); return; }
          }
          const touchesLocked = (() => {
            for (let i = minPos; i <= maxPos; i++){
              const r = mode === 'row' ? line : i; const c = mode === 'row' ? i : line;
              const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
              for (const [dr,dc] of dirs){ const nr=r+dr, nc=c+dc; if (inBounds(nr, nc) && isLockedCell(nr, nc)) return true; }
            }
            return false;
          })();
          // First move must cover center; otherwise moves must touch an existing locked tile
          if (lockedCells.length === 0) {
            const coversCenter = (mode === 'row' && line === 7 && minPos <= 7 && maxPos >= 7) ||
                                 (mode === 'col' && line === 7 && minPos <= 7 && maxPos >= 7);
            if (!coversCenter) { setValidity(false); updateScore(0); return; }
          } else {
            if (!touchesLocked) { setValidity(false); updateScore(0); return; }
          }
          const segScore = computeTotalScore(mode, line, minPos, maxPos);
          updateScore(segScore);
          const dictOk = validateBoardWords();
          setValidity(!!dictOk);
        }

        function updateScore(score) {
          const usage = computeUsage();
          const used = (Object.values(usage.letters).reduce((a,b)=>a+b,0) + usage.blanks);
          const isBingo = used === 7;
          const total = score + (isBingo ? 50 : 0);
          scoreEl.textContent = String(total);
          bingoMsg.style.display = isBingo ? 'block' : 'none';
        }

        function validateBoardWords() {
          const words = [];
          const toWord = arr => arr.filter(Boolean).join('');
          function includesNewTile(positions) {
            for (const [r,c] of positions) {
              const sq = board.children[idx(r, c)];
              if (sq && !sq.classList.contains('locked') && hasLetter(sq)) return true;
            }
            return false;
          }
          // Detect if there are any newly placed tiles
          let hasNewTiles = false;
          for (let i=0;i<board.children.length;i++){
            const sq = board.children[i];
            if (sq && !sq.classList.contains('locked') && hasLetter(sq)) { hasNewTiles = true; break; }
          }
          const G = Array.from({length:size},()=>Array(size).fill(''));
          for (let r=0;r<size;r++){ for (let c=0;c<size;c++){ G[r][c] = getChar(r,c); } }
          for (let r=0; r<size; r++) {
            let c=0; while (c < size) {
              while (c < size && !G[r][c]) c++; let start=c; while (c < size && G[r][c]) c++; let end=c-1;
              const len = end-start+1; if (len >= 2) {
                const w = toWord(G[r].slice(start, end+1)); const pos = []; for (let cc=start; cc<=end; cc++) pos.push([r,cc]);
                if (!hasNewTiles || includesNewTile(pos)) words.push({word:w, dir:'‚Üí', r, c:start});
              }
            }
          }
          for (let c=0; c<size; c++) {
            let r=0; while (r < size) {
              while (r < size && !G[r][c]) r++; let start=r; while (r < size && G[r][c]) r++; let end=r-1;
              const len = end-start+1; if (len >= 2) {
                const col = []; for (let rr=start; rr<=end; rr++) col.push(G[rr][c]);
                const w = toWord(col); const pos = []; for (let rr=start; rr<=end; rr++) pos.push([rr,c]);
                if (!hasNewTiles || includesNewTile(pos)) words.push({word:w, dir:'‚Üì', r:start, c});
              }
            }
          }
          const dict = window.SCRABBLE_DICT || {};
          const frag = document.createDocumentFragment();
          let dictOk = true;
          if (words.length === 0) { const p = document.createElement('div'); p.textContent = 'No 2+ letter words on board.'; frag.appendChild(p); }
          else { for (const {word, dir} of words) { const item = document.createElement('div'); item.className = 'wordItem'; const left = document.createElement('span'); left.textContent = `${word} ${dir}`; const ok = document.createElement('span'); const valid = !!dict[word]; if (!valid) dictOk = false; ok.textContent = valid ? 'YES' : 'NO'; ok.className = valid ? 'ok' : 'bad'; item.appendChild(left); item.appendChild(ok); frag.appendChild(item); } }
          wordsListEl.innerHTML = ''; wordsListEl.appendChild(frag);
          return dictOk;
        }

        function toggleBoard(){ puzzleMode ? unlockBoard() : lockBoard(); updateToggleLabels(); }
        function toggleRack(){ rackLocked ? unlockRack() : lockRack(); updateToggleLabels(); }
        function updateToggleLabels(){ boardToggleBtn.textContent = puzzleMode ? 'Unlock Board' : 'Lock Board'; rackToggleBtn.textContent = rackLocked ? 'Unlock Rack' : 'Lock Rack'; const canExport = puzzleMode && rackLocked; const exportBtnEl = document.getElementById('exportBtn'); if (exportBtnEl) exportBtnEl.disabled = !canExport; }
      })();
    </script>
  </body>
  </html>
